<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>文档 | BD.Common8</title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content=" | BD.Common8 文档 ">
      
      <link rel="icon" href="../favicon.ico">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      
      
      
      <meta name="docfx:docurl" content="https://github.com/BeyondDimension/Common/blob/dev8/doc/Redis.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">
  </head>

  <script type="module" src="./../public/docfx.min.js"></script>

  <script>
    const theme = localStorage.getItem('theme') || 'auto'
    document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
  </script>


  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../res/DocFXIcon.png" alt="Common8">
            Common8
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">

        <article data-uid="">

<h3 id="redis分布式缓存">Redis/分布式缓存</h3>
<p><a href="https://learn.microsoft.com/zh-cn/aspnet/core/performance/caching/distributed">ASP.NET Core 中的分布式缓存</a>
使用接口 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.caching.distributed.idistributedcache">IDistributedCache</a> 该接口的实现有三种可选方案<br>
之前用过 SqlServer 的版本所以 EF 的文档中有相关的命令行记录，但现在通常使用 Redis</p>
<ul>
<li>若要使用 SQL Server 分布式缓存，请添加对 Microsoft.Extensions.Caching.SqlServer 包的包引用。</li>
<li>若要使用 Redis 分布式缓存，请添加对 Microsoft.Extensions.Caching.StackExchangeRedis 包的包引用。</li>
<li>若要使用 NCache 分布式缓存，请添加对 NCache.Microsoft.Extensions.Caching.OpenSource 包的包引用。</li>
</ul>
<p>在我们项目中封装了一个函数 <code>AddStackExchangeRedisCache</code><br>
从 <code>appsettings.json</code> 中 <code>ConnectionStrings</code> 中读取 <code>RedisConnection</code> 写上连接字符串
通过构造函数注入类型</p>
<ul>
<li><code>IDistributedCache</code>(此类型为通用的抽象类型仅提供简单的键值对存储)</li>
<li><code>StackExchange.Redis.IConnectionMultiplexer</code>(原始 Redis SDK 连接，通常用于需要使用更高级的功能)</li>
</ul>
<p>自定义数据类型建立模型类，推荐使用 C# 9.0 中新增的 <a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/record">record</a> 类型</p>
<ul>
<li>对于<strong>可读性要求</strong>高的，就使用<a href="Serializable-And-Deserialize.html">序列化与反序列化文档</a>中的 System.Text.Json 将模型类序列化成 Json 字符串存入</li>
<li>对于<strong>性能</strong>要求高的，就使用<a href="Serializable-And-Deserialize.html">序列化与反序列化文档</a>中的 <strong>Memory</strong>Pack 将模型类序列化成 Byte[] 存入缓存中</li>
</ul>
<p>在<a href="https://github.com/BeyondDimension/Common/blob/1.23.10309.12315/src/BD.Common.AspNetCore/Extensions/CacheExtensions.cs">通用库 BD.Common.AspNetCore 中的扩展</a></p>
<ul>
<li>GetAsync/SetAsync 使用的是 <strong>Message</strong>Pack</li>
<li>GetV2Async/SetV2Async 使用的是 <strong>Memory</strong>Pack</li>
</ul>
<h4 id="用例">用例</h4>
<pre><code>/// &lt;summary&gt;
/// 网络加速
/// &lt;/summary&gt;
public sealed class AccelerateController : ApiController.AllowAnonymous
{
    readonly IDistributedCache cache;
    ...
    public AccelerateController(
        ...
        IDistributedCache cache,
        ILogger&lt;AccelerateController&gt; logger) : base(logger)
    {
        ...
        this.cache = cache;
    }

    /// &lt;summary&gt;
    /// 获取所有加速项目组数据
    /// &lt;/summary&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    [HttpGet(&quot;[action]&quot;)]
    public async Task&lt;ApiRsp&lt;AccelerateProjectGroupDTO[]?&gt;&gt; All()
    {
        ...
        // 从缓存中取出所有加速项目组数据，赞助用户与非赞助用户的 key 不同
        result = await cache.GetAsync&lt;AccelerateProjectGroupDTO[]&gt;(key, HttpContext.RequestAborted);
        return ApiRspHelper.Ok(result ?? Array.Empty&lt;AccelerateProjectGroupDTO&gt;());
    }
</code></pre>
<pre><code>/// &lt;summary&gt;
/// 平台登录
/// &lt;/summary&gt;
public sealed class LoginController : AllowAnonymousApiController&lt;LoginController&gt;
{
    readonly IDistributedCache cache;
    ...
    public LoginController(
        ...
        IDistributedCache cache,
        ILogger&lt;LoginController&gt; logger) : base(logger)
    {
        ...
        this.cache = cache;
    }

    /// &lt;summary&gt;
    /// 管理后台登录
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;args&quot;&gt;加密了的用户名与密码&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    [ProducesResponseType(StatusCodes.Status400BadRequest)]
    [HttpPost]
    public async Task&lt;ActionResult&lt;ApiResponse&lt;JWTEntity&gt;&gt;&gt; Post([FromBody] string[] args)
    {
        // 从缓存中取出当前客户端 IP 登录失败次数，当超过最大限制时返回状态码 TooManyRequests
        var ipAccessFailedCount = await cache.GetAsync&lt;int&gt;(ipCacheKey, HttpContext.RequestAborted);
        if (ipAccessFailedCount &gt;= MaxIpAccessFailedCount)
            return StatusCode((int)HttpStatusCode.TooManyRequests);
        ...
        // 登录失败时，增加一个计数，并且设置缓存到期时间
        var lockoutEnd = DateTimeOffset.Now + options.Lockout.DefaultLockoutTimeSpan.Duration();
        await cache.SetAsync(ipCacheKey, ipAccessFailedCount + 1,
            new DistributedCacheEntryOptions { AbsoluteExpiration = lockoutEnd });
    }
}
</code></pre>
<pre><code>/// &lt;summary&gt;
/// 广告
/// &lt;/summary&gt;
[RequiredSecurityKey]
[Route(&quot;api/[controller]/[action]&quot;)]
public sealed class AdvertisementController : ApiController.AllowAnonymous
{
    readonly IDistributedCache cache;
    readonly IConnectionMultiplexer connection;

    public AdvertisementController(
        IDistributedCache cache,
        IConnectionMultiplexer connection,
        ILogger&lt;AdvertisementController&gt; logger) : base(logger)
    {
        this.cache = cache;
        this.connection = connection;
    }

    /// &lt;summary&gt;
    /// 获取广告列表
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;type&quot;&gt;广告类型&lt;/param&gt;
    /// &lt;param name=&quot;platform&quot;&gt;&lt;/param&gt;
    /// &lt;param name=&quot;deviceIdiom&quot;&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    [HttpGet(&quot;{platform}/{deviceIdiom}&quot;)]
    public async Task&lt;ApiRsp&lt;AdvertisementDTO[]?&gt;&gt; All(
        [FromQuery] AdvertisementType? type,
        [FromRoute] Platform platform = Platform.Windows,
        [FromRoute] DeviceIdiom deviceIdiom = DeviceIdiom.Desktop)
    {
        var info = await cache.GetAsync&lt;AdvertisementCacheDTO[]&gt;(CacheKeys.AdvertisementSponsorCacheKey);
        if (info != null)
        {
            var r = info.Where(x =&gt; type.HasValue ? x.Type == type : true &amp;&amp;
                x.Platform.HasFlag(platform) &amp;&amp;
                x.DeviceIdiom.HasFlag(deviceIdiom))
                .Select(x =&gt; new AdvertisementDTO
                {
                    Id = x.Id,
                    Order = x.Order,
                    Type = x.Type,
                    Standard = x.Standard,
                    Remark = x.Remark,
                }).ToArray();
            return r;
        }
        return Array.Empty&lt;AdvertisementDTO&gt;();
    }

    /// &lt;summary&gt;
    /// 访问广告图片
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;id&quot;&gt;广告 Id&lt;/param&gt;
    /// &lt;returns&gt;302 跳转到广告图&lt;/returns&gt;
    [HttpGet(&quot;{id?}&quot;)]
    public async Task&lt;IActionResult&gt; Images([FromRoute] Guid? id)
    {
        if (id.HasValue)
        {
            var info = await cache.GetAsync&lt;AdvertisementCacheDTO&gt;(id.Value.ToString());
            if (info != null)
            {
                var dbConnection = connection.GetDatabase(1, HttpContext.RequestAborted);
                await dbConnection.HashIncrementAsync(CacheKeys.AdvertisementImagesHashKey, id.Value.ToString());
                return Redirect(info!.Url);
            }
        }
        return Redirect(&quot;https://steampp.net/logo.svg&quot;);
    }

    /// &lt;summary&gt;
    /// 访问广告连接
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;id&quot;&gt;广告 Id&lt;/param&gt;
    /// &lt;returns&gt;302 跳转到地址&lt;/returns&gt;
    [HttpGet(&quot;{id?}&quot;)]
    public async Task&lt;IActionResult&gt; Jump([FromRoute] Guid? id)
    {
        if (id.HasValue)
        {
            var info = await cache.GetAsync&lt;AdvertisementCacheDTO&gt;(id.Value.ToString());
            if (info != null)
            {
                var dbConnection = connection.GetDatabase(1, HttpContext.RequestAborted);
                await dbConnection.HashIncrementAsync(CacheKeys.AdvertisementJumpHashKey, id.Value.ToString());
                return Redirect(info!.JumpUrl);
            }
        }
        return Redirect(&quot;https://steampp.net&quot;);
    }
}
</code></pre>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/BeyondDimension/Common/blob/dev8/doc/Redis.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          ©️ 江苏蒸汽凡星科技有限公司. All rights reserved.
        </div>
      </div>
    </footer>
  </body>
</html>
