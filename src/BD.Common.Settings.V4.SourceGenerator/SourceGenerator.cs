using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System.Text;

namespace BD.Common.Settings.SourceGenerator;

[Generator]
public sealed class SourceGenerator : ISourceGenerator
{
    const string k__BackingField = "k__BackingField";
    const string SettingsProperty = "BD.Common.Settings.SettingsProperty";
    const string SettingsStructProperty = "BD.Common.Settings.SettingsStructProperty";

    record class SettingsPropertyModel(string Name, string Type, string ClassName);

    readonly Dictionary<string, MemoryStream> modelClassFile = new();
    readonly Dictionary<string, int> orders = new();

    static void Write(Stream stream, ReadOnlySpan<byte> bytes)
    {
        var buffer = bytes.ToArray();
        stream.Write(buffer, 0, buffer.Length);
    }
    static void Write(Stream stream, string str)
    {
        var buffer = Encoding.UTF8.GetBytes(str);
        stream.Write(buffer, 0, buffer.Length);
    }

    void Write(ITypeSymbol symbol)
    {
        foreach (var field in symbol.GetMembers().OfType<IFieldSymbol>())
        {
            var propertyName = field.Name;
            if (propertyName.StartsWith("Default")) continue;

            propertyName = propertyName.Substring(1,
                propertyName.Length - k__BackingField.Length - 2);

            var propertyType = field.Type.ToDisplayString();
            if (propertyType.StartsWith(SettingsProperty))
            {
                propertyType = propertyType[(SettingsProperty.Length + 1)..^1];
            }
            else if (propertyType.StartsWith(SettingsStructProperty))
            {
                propertyType = propertyType[(SettingsStructProperty.Length + 1)..^1];
            }
            var types = propertyType.Split(',');
            string type, classFullName;
            switch (types.Length)
            {
                case 2:
                    type = types[0].Trim();
                    classFullName = types[1].Trim();
                    break;
                case 3:
                    type = types[1].Trim();
                    classFullName = types[2].Trim();
                    break;
                default:
                    continue;
            }

            var classNameLastIndexOf = classFullName.LastIndexOf('.');
            var classNamespace = classFullName[..classNameLastIndexOf];
            var className = classFullName.Substring(classNameLastIndexOf + 1, classFullName.Length - classNameLastIndexOf - 1);

            if (!modelClassFile.TryGetValue(classFullName, out var memoryStream))
            {
                var classNameTrim = className.TrimEnd('_');
                memoryStream = new MemoryStream();
                modelClassFile[classFullName] = memoryStream;
                Write(memoryStream, """
                    #nullable enable
                    // <auto-generated/>
                    // ReSharper disable once CheckNamespace
                    namespace 
                    """u8);
                Write(memoryStream, classNamespace);
                Write(memoryStream, ";\r\n\r\ninternal partial class "u8);
                Write(memoryStream, classNameTrim);
                Write(memoryStream, "Context : JsonSerializerContext\r\n{\r\n    static "u8);
                Write(memoryStream, classNameTrim);
                Write(memoryStream, "Context? instance;\r\n\r\n    public static "u8);
                Write(memoryStream, classNameTrim);
                Write(memoryStream, "Context Instance\r\n        => instance ??= new "u8);
                Write(memoryStream, classNameTrim);
                Write(memoryStream, "Context(ISettings.GetDefaultOptions());\r\n}"u8);

                Write(memoryStream, "\r\n\r\n[MPObj, MP2Obj(SerializeLayout.Explicit)]\r\n"u8);
                Write(memoryStream, "partial class "u8);
                Write(memoryStream, className);
                Write(memoryStream, " : I"u8);
                Write(memoryStream, classNameTrim);
                Write(memoryStream, ", ISettings, ISettings<"u8);
                Write(memoryStream, className);
                Write(memoryStream, ">\r\n{\r\n    public const string Name = nameof("u8);
                Write(memoryStream, classNameTrim);
                Write(memoryStream, ");\r\n\r\n    static string ISettings.Name => Name;\r\n\r\n    static JsonSerializerContext ISettings.JsonSerializerContext\r\n"u8);
                Write(memoryStream, "        => "u8);
                Write(memoryStream, classNameTrim);
                Write(memoryStream, "Context.Instance;\r\n\r\n    static JsonTypeInfo ISettings.JsonTypeInfo\r\n        => "u8);
                Write(memoryStream, classNameTrim);
                Write(memoryStream, "Context.Instance."u8);
                Write(memoryStream, className);
                Write(memoryStream, ";\r\n\r\n    static JsonTypeInfo<"u8);
                Write(memoryStream, className);
                Write(memoryStream, "> ISettings<"u8);
                Write(memoryStream, className);
                Write(memoryStream, ">.JsonTypeInfo\r\n        => "u8);
                Write(memoryStream, classNameTrim);
                Write(memoryStream, "Context.Instance."u8);
                Write(memoryStream, className);
                Write(memoryStream, ";\r\n\r\n"u8);

            }

            if (!orders.ContainsKey(classFullName))
                orders[classFullName] = 0;

            Write(memoryStream, "    [MPKey("u8);
            var order = orders[classFullName].ToString();
            Write(memoryStream, order);
            Write(memoryStream, "), MP2Key("u8);
            Write(memoryStream, order);
            Write(memoryStream, "), JsonPropertyOrder("u8);
            Write(memoryStream, order);
            Write(memoryStream, ")]\r\n"u8);
            orders[classFullName] = orders[classFullName] + 1;
            Write(memoryStream, "    public "u8);
            Write(memoryStream, type);
            Write(memoryStream, "? "u8);
            Write(memoryStream, propertyName);
            Write(memoryStream, " { get; set; }\r\n\r\n"u8);
        }
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxReceiver is not SyntaxReceiver receiver)
            return;

        var compilation = context.Compilation;

        // loop over the candidate fields, and keep the ones that are actually annotated
        //var symbols = new List<ITypeSymbol>();
        foreach (var decl in receiver.Candidates)
        {
            var model = compilation.GetSemanticModel(decl.SyntaxTree);
            if (model.GetDeclaredSymbol(decl, context.CancellationToken) is ITypeSymbol symbol)
            {
                Write(symbol);
                //symbols.Add(symbol);
            }
        }

        orders.Clear();
        foreach (var item in modelClassFile)
        {
            Write(item.Value, "}\r\n\r\n");
            context.AddSource($"{item.Key}.class.g.cs", SourceText.From(item.Value, Encoding.UTF8, canBeEmbedded: true));
        }
        modelClassFile.Clear();

        //foreach (var symbol in symbols)
        //{
        //    var code = new StringBuilder();
        //    // Build up the source code
        //    //string source = $@"// <auto-generated/>

        //    //";
        //    // 遍历 settings 类型的所有属性。
        //    foreach (var field in symbol.GetMembers().OfType<IFieldSymbol>())
        //    {
        //        // 获取属性名和属性类型。
        //        var propertyName = field.Name;
        //        var propertyType = field.Type.ToDisplayString();

        //        // 生成代码，打印属性值。
        //        code.AppendLine($"// \"{propertyName}: {0}\", type:{propertyType}");
        //    }
        //    context.AddSource($"{symbol.Name}.g.cs", SourceText.From(code.ToString(), Encoding.UTF8));
        //}
    }

    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
    }
}
